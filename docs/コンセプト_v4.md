# HiveForge — Prototype Assembly（POC）v4

> 実験的・自律型ソフトウェア組立システム
>
> v4の目的：**v3をベースに、現状の実装（POC）とズレが出ないように設計仕様を更新しつつ、次の判断点を明確にして前進できる“作業用仕様”にする**。
>
> 作成日: 2026-02-01

---

## このドキュメントの位置づけ

- v3は「一通りの設計仕様」をまとめたもの
- v4は「v3を土台に、今のリポジトリの実装・運用・テスト方針に合わせて進めるための更新版」
- 原則として、**既存実装がある箇所は実装に合わせて仕様を寄せる**（ただし問題がある場合は v4 で仕様変更を提案し、Decisionに落とす）

参照（ベースライン）:
- [コンセプト_v3.md](コンセプト_v3.md)

---

## v4でまずやること（進め方）

1. **v3→v4差分をDecision化**（「何を変えるか」をイベントとして残す）
2. **最小の仕様変更→テスト追加**（TDDで仕様＝テストに落とす）
3. **Core / MCP / 拡張の境界を再確認**（責務の漏れ・重複を無くす）

---

## v3からの差分（暫定）

> ここは“変更ログ”として運用する。変更は必ず「理由」と「影響範囲」を書く。

### ドキュメント配置

- **変更**: `コンセプト_v3.md` を `docs/` 配下へ移動
- **理由**: ドキュメント集約・参照リンクの一貫性
- **影響**: README / ARCHITECTURE / issue doc のリンク更新

### 用語・表現

- **方針**: v3の用語集は維持しつつ、実装で使っている名称に寄せる（例: 既存モジュール名/イベント型）

---

## v3「POCのゴール（DoD）」と現状の一致確認（2026-02-01）

> 目的：v3のDoDが「今の実装・テスト」でどこまで満たされているかを明確にし、v4で直すべき差分を特定する。

検証方針:
- **✅=テストで根拠あり**（Pythonユニットテスト等）
- **🟡=実装はあるが手動確認/不足**（UIやCopilot設定など）
- **🔴=未実装/要設計**

| v3 DoD | 現状 | 根拠（代表） | v4での差分/次アクション |
|---|---:|---|---|
| VS CodeでCopilot Chat経由でHiveForgeと対話できる | 🟡 | MCP実装: `src/hiveforge/mcp_server/server.py` / ツール定義: `src/hiveforge/mcp_server/tools.py` | Copilot側のMCP設定手順をv4（またはQUICKSTART）に明文化。必要なら「v3互換ツール名」提供も検討。 |
| VS Code拡張でダッシュボード・イベントログが確認できる | 🟡 | イベントログ(TreeView): `vscode-extension/src/providers/eventsProvider.ts` / ダッシュボード: `vscode-extension/src/commands/runCommands.ts`（現状は"開発中"表示） | ダッシュボードは未実装扱い。v4で「ダッシュボード=TreeView中心」へ仕様変更するか、Webviewの実装を追加するかDecision化。 |
| 要求を投入すると、AR（イベントログ）に記録される | ✅ | AR追記/リプレイ: `tests/test_ar.py` / MCPハンドラがARへ追記: `tests/test_mcp_server.py` | v3の「要求(Requirement)」と実装の「確認要請(requirement)」が意味的にズレているため、用語整理（D3）を先に決める。 |
| タスクが生成・実行され、状態遷移が確認できる | ✅ | 状態機械: `tests/test_state_machines.py` / API経由のRun/Task操作: `tests/test_api.py` / MCPのTask操作: `tests/test_mcp_server.py` | “実行”の定義をv4で明確化（POCではタスクはイベント記録＋状態遷移が中心）。 |
| 任意の成果物から「なぜ」を遡及できる（因果リンク） | ✅ | Lineage(MCP): `src/hiveforge/mcp_server/handlers/lineage.py` / テスト: `tests/test_mcp_server.py` | Issue #001の「自動parents付与」と現状の「任意指定parents」の整合を取る（仕様統合）。 |
| 沈黙（タイムアウト）が検出され、記録・停止が発動する | ✅ | 沈黙検出: `src/hiveforge/silence.py` / テスト: `tests/test_silence.py` | “停止が発動”の範囲（Run中断/イベントのみ/通知）をv4で厳密化。 |
| 緊急停止（EmergencyStop）が機能する | ✅ | MCP緊急停止テスト: `tests/test_mcp_server.py` / APIルート: `src/hiveforge/api/routes/runs.py` / 拡張のRun中止: `vscode-extension/src/commands/runCommands.ts` | scope=systemの扱い（POCでどこまで止めるか）をv4で明確化。 |

---

## v3仕様と現状実装のインターフェース差分（重要）

### 1) 「Requirement」の意味

- v3: **Requirement = ユーザー要求そのもの**（要求→分析→承認→タスク化）
- 現状実装: **requirement = ユーザーへの確認要請**（pending/approved等の状態機械）

このズレは、ドキュメントだけでなく **UI/API/MCPの概念設計** に波及するため、v4で早めに決める。

### 2) MCPツール名の差分

v3に書かれている例（`submit_requirement`, `list_tasks`, `get_status` など）は、現状のMCP実装では以下に相当/代替される:

- v3 `submit_requirement` → 現状は `start_run(goal=...)` + 必要なら `create_requirement(description=...)`
- v3 `list_tasks` → 現状は `get_run_status` で集約表示（詳細一覧はAPI/拡張側）
- v3 `get_status` → 現状は `get_run_status`

この差分は「v3を直す」のではなく、v4で **どちらを正とするか**（互換レイヤを作るか/ドキュメントを寄せるか）をDecision化する。

---

## v4の論点（Decision候補）

### D1. 仕様変更の承認フロー

- **論点**: 仕様の変更（v4更新）をどの粒度でDecisionにするか
- **案**:
  - A: 章単位（大きいが追跡しやすい）
  - B: ルール単位（細かいがレビュー負荷）
- **推奨（暫定）**: B だが、POCでは「影響範囲が広い変更」だけAでまとめる

### D2. “実装が先/仕様が先”の優先順位

- **論点**: 既に動いている挙動が仕様と違う場合
- **原則（暫定）**:
  - バグ/危険/不整合 → 仕様側を変える前に、まず問題の性質を明確化しテストを書く
  - 仕様が妥当で実装がズレている → 実装を直す
  - 仕様が現実的でない → 仕様変更（Decision化）

### D3. Requirement/Decisionの意味づけ（用語統合）

- **論点**: "Requirement"を「ユーザー要求」として扱うのか、「確認要請」として扱うのか
- **影響範囲**: イベント型、状態機械、APIパス、VS Code拡張の表示、MCPツール名
- **選択肢（暫定）**:
  - A: v3に合わせて「ユーザー要求=Requirement」を導入し、確認要請はDecisionに寄せる
  - B: 現状実装に合わせて「requirement=確認要請」を正とし、ユーザー要求はRun.goal/Artifactに寄せる
  - C: Requirementを2階層（UserRequirement / ApprovalRequest）に分割

#### C案: UserRequirement / ApprovalRequest の2階層（v4推奨・暫定）

狙いは「v3の“ユーザー要求”」と「現状実装の“確認要請”」を両方正しく扱い、UI/API/MCP上の混乱を減らすこと。

##### 用語定義（v4）

- **UserRequirement**: ユーザーがこのRunで達成したい要求（v3のRequirement相当）
  - POCでは Runの `goal` を一次ソースとする（Run開始時に確定）
  - 例: 「ユーザー認証機能を実装する」
- **ApprovalRequest**: 実行中に発生する“ユーザーへの確認要請”（現状実装のRequirement相当）
  - 状態: `pending / approved / rejected`
  - 例: 「OAuthにする？パスワード認証にする？」
- **Decision**: ApprovalRequestの解決結果（承認/却下、選択肢、コメント）
  - “Decision”は概念名であり、POCでは既存イベント `requirement.approved / requirement.rejected` に格納される

##### 現状実装へのマッピング（POC）

| v4概念 | 現状の実体 | 備考 |
|---|---|---|
| UserRequirement | `RunStartedEvent.payload.goal` / APIの `Run.goal` | Run開始時点のユーザー要求として扱う |
| ApprovalRequest | `RequirementCreatedEvent` + `RequirementStateMachine` | ただし名称は実装上 “Requirement” のまま |
| Decision | `RequirementApprovedEvent` / `RequirementRejectedEvent` | `selected_option` / `comment` をpayloadに保持 |

##### UI/API/MCPの表示ルール（v4）

- UI/ドキュメント上は **原則として“確認要請=ApprovalRequest”** と表記する
  - VS Code拡張のView名が既に「確認要請」なので、この方針と整合する
- `Requirement` という単語は、**イベント型/既存API名の互換のために残る**
  - POC段階での破壊的リネームは行わない（互換性と作業量の観点）

##### 仕様上の効果

- v3の「要求を投入する」= Run開始（UserRequirementの確定）として整理できる
- 実装の `create_requirement` は「要件投入」ではなく「確認要請の作成」と説明できる
- “Decision”は「承認/却下イベント」としてイベントソーシングに自然に乗る

##### 追加で検討する拡張（将来）

- UserRequirementをRun.goalだけでなく、明示イベントとして永続化したい場合:
  - 例: `user_requirement.submitted` の導入
  - ただしPOCでは **RunStartedEventに含まれているため必須ではない**

##### テスト/実装の次アクション（TDDの入口）

- v4ドキュメントの用語統一に合わせて、以下を先にテストで固定する:
  - Run開始時の `goal` が「ユーザー要求(UserRequirement)」の一次ソースであること
  - `create_requirement` が「確認要請(ApprovalRequest)」を作り、承認/却下で状態遷移すること

### D4. イベントハッシュに含めるフィールド

- **論点**: `BaseEvent.hash` の計算対象に何を含めるか
- **現状実装**: `hash` は `id` / `timestamp` / `payload` / `prev_hash` / `parents` 等を含む（`hash`自身のみ除外）
  - 結果として、同じpayloadでも `id` と `timestamp` が異なる限りハッシュは一致しない
  - `prev_hash` を含むため、ハッシュチェーン（改ざん検出）が成立する
- **選択肢（暫定）**:
  - A: 現状維持（イベント単位の一意性とチェーンを優先）
  - B: “内容ハッシュ(content hash)” を別フィールドとして追加（同一内容の同一性比較用）
  - C: `timestamp` を除外してイベント比較しやすくする（ただし順序・一意性の保証が弱くなる）

---

## 次に編集する場所（TODO）

- [x] v3「POCのゴール（DoD）」と、現状のテスト/実装の一致確認（差分を列挙）
- [x] “イベントの正規化（JCS/RFC8785）”と実装の一致確認（本ドキュメントに追記）
- [x] “因果リンク（lineage）”の仕様を Issue #001 の内容と統合（本ドキュメントに追記）
- [x] VS Code拡張のUI要件（ダッシュボード/ログ/因果グラフ）を現状実装に合わせて更新（本ドキュメントに追記）

---

## 仕様（v4）: イベントの正規化（JCS/RFC8785）とハッシュ

この章は、現状の実装（POC）を正として仕様を固定する。

### 目的

- イベントの改ざん検出（ハッシュチェーン）
- 事後検証（同一Runのイベント列が整合しているか）
- 永続化(JSONL)と通信(JSON)で同一のハッシュが得られること

### 実装上の事実（POC）

- ハッシュ計算は `src/hiveforge/core/events.py` の `compute_hash()` で行う
- `jcs.canonicalize()` を用いて JCS (RFC 8785) で正規化した上で、SHA-256を取る
- `compute_hash()` は `hash` フィールド自身のみ除外する
  - それ以外（`id`, `timestamp`, `prev_hash`, `parents`, `payload` 等）はハッシュ対象
- JSON化の都合で `datetime` や `Enum` 等は `_serialize_value()` で文字列へ正規化する

### 設計上の含意（仕様として明文化）

- **イベントのハッシュは“イベントの一意性”を表す**
  - 同じpayloadでも、`id` / `timestamp` が異なれば別イベントとして扱い、ハッシュも別になる
- **ハッシュチェーンの結合点は `prev_hash`**
  - `prev_hash` は直前イベントの `hash` を保持し、次イベントの `hash` 計算に含まれる
  - よって、途中のイベントが改ざんされると、以降の整合性検証が失敗する

### AR（Akashic Record）での `prev_hash` 設定

- `src/hiveforge/core/ar/storage.py` の `AkashicRecord.append()` が、追記時に `prev_hash` を自動設定する
- ファイルロック下で「末尾ハッシュ取得 → 追記」をアトミックに行い、再起動/複数プロセスでも整合を維持する
- 整合性検証は `AkashicRecord.verify_chain()` が担う（`prev_hash` が連結していることを確認）

### テスト根拠（POC）

- `tests/test_events.py` にて以下を検証している:
  - 決定論的ハッシュ（同一データ→同一ハッシュ）
  - `hash` フィールド除外
  - キー順序に依存しない（JCS正規化）
  - `_serialize_value()` が `datetime` をISO文字列化する

---

## 仕様（v4）: 因果リンク（Lineage）

### 目的

- 任意のイベント/成果物から「なぜ」を遡及できること
- UI/ツールが、原因（祖先）と結果（子孫）を探索できること

### データモデル

- すべてのイベントは `parents: list[str]` を持つ（親イベントIDの配列）
  - `parents` は「因果リンク」であり、ハッシュチェーン（`prev_hash`）とは別物
  - `parents` はイベントのハッシュ計算に含まれるため、**後から付与/変更はできない**（イミュータブル）

### 探索API（MCP）

- MCPツール `get_lineage(event_id, direction, max_depth)` を提供する
  - `direction`: `ancestors | descendants | both`
  - `max_depth`: 探索深度の上限
- 実装は `src/hiveforge/mcp_server/handlers/lineage.py`
  - 祖先探索: `parents` を辿るBFS
  - 子孫探索: 全イベント走査で `parents` に含まれるものを探すBFS
  - `max_depth` 到達時は `truncated=true`

### 現状の制約（POC）

- `parents` は **明示指定できる**（上書きしない）
- `parents` が未指定（空）の場合は、**ハンドラー側で自動補完**される
  - API: `src/hiveforge/api/routes/tasks.py`, `src/hiveforge/api/routes/runs.py`
  - MCP: `src/hiveforge/mcp_server/handlers/task.py`, `src/hiveforge/mcp_server/handlers/run.py`

### Issue #001（自動parents付与）の統合

Issueの趣旨をv4仕様に取り込み、POCの次の実装ターゲットとして明確化する。

- **追加仕様（提案）**: 作成イベントに対して、`parents` が未指定（空）なら自動で親を補完する
  - 明示指定がある場合はそれを優先（上書きしない）

#### 自動付与ルール（提案・Issue #001由来）

| イベント | デフォルトparents（候補） |
|---|---|
| `task.created` | `run.started` |
| `task.assigned` | 対応する `task.created` |
| `task.progressed` | 対応する `task.created` |
| `task.completed` | 対応する `task.created` |
| `task.failed` | 対応する `task.created` |
| `run.completed` | 全ての `task.completed`（またはRunの最終状態を代表するイベント） |

補足:

- `run.completed` の `parents` は「Run完了の根拠となったイベント」を指す
  - 通常: **全ての `task.completed`**
  - `force=true`（強制完了）の場合: 通常の `task.completed` に加えて、
    - 自動生成されたキャンセル用 `task.failed`（"Runが強制完了されたためキャンセル"）
    - 自動生成された却下用 `requirement.rejected`（未解決の確認要請があれば）
- `parents` を明示指定した場合はそれを優先し、自動補完しない

#### Decision（確定）

- **D5. 自動parents付与の責務境界（決定）**
  - 選択: **A（MCP/APIハンドラー層で付与）**
  - 理由: ユーザー操作（コマンド）に近い層で「デフォルト因果」を補完し、明示指定の自由度も残せる
  - 補足: 将来的にCoreのユースケース層を導入する場合（C）は移設候補

---

## 仕様（v4）: VS Code拡張UI要件（現状実装に寄せる）

### POCのUIゴール

- “ダッシュボード”は Webview 1枚よりも、**TreeView中心の運用UI**として成立していれば良い
- 重要なのは「Run/Task/確認要請/イベントログ」を素早く行き来できること

### 情報アーキテクチャ（現状）

- Activity Barに `HiveForge` コンテナを持つ
- 主要View（TreeView）:
  - Runs: `hiveforge.runs`
  - Tasks: `hiveforge.tasks`
  - 確認要請: `hiveforge.requirements`
  - Events: `hiveforge.events`

### 主要インタラクション（現状）

- Run選択（Runsクリック）で `currentRunId` を切替え、Tasks/確認要請/EventsがそのRunに追随
- フィルタ切替:
  - Runs: 完了済みの表示/非表示
  - Tasks: 完了/失敗の表示/非表示
  - 確認要請: 解決済みの表示/非表示
- 確認要請:
  - TreeViewのインライン操作で承認/却下
  - クリックで詳細Webview（選択肢/コメント入力つき）を表示
- イベントログ:
  - 選択Runのイベントを新しい順に表示
  - クリックでイベント詳細を表示（コマンドは存在、詳細表示の内容は今後拡張余地）

### ダッシュボードコマンドの扱い

- `hiveforge.showDashboard` は現状 “開発中” 表示のプレースホルダー
- v4では、以下のどちらかをDecision化する:
  - A: TreeView群こそがダッシュボードであり、`showDashboard` は不要/後回し
  - B: Webviewダッシュボードを実装し、TreeViewはナビゲーション/操作UIに特化

---

## メモ

- v4は「完成品」ではなく、**実装と一緒に育てる仕様**として扱う
- 変更は必ず、テストかイベント（Decision等）に落とす
